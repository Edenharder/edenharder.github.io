---
layout: post
title: 双随机矩阵
categories: [Math]
tags: [Life,Math]
---

<h1>{{ page.title }}</h1>


<div id="TOC">
<ul>
<li><a href="#part-1">Part 1</a></li>
<li><a href="#part-2">Part 2</a></li>
</ul>
</div>
<p>没想到竟遇到了双随机矩阵！！！第一部分主要讲遇到的问题，第二部分讲双随机矩阵。</p>
<h2 id="part-1"><a href="#part-1">Part 1</a></h2>
<p>做东西时遇到这样一个小问题：</p>
<blockquote>
<p>If <span class="math">\(0\le a_1 \le a_2\le \ldots \le a_n\)</span>, <span class="math">\(0\le b_1 \le b_2\le \ldots \le b_n\)</span>, <span class="math">\(\sum_{i=1}^n m_{ij} \le 1, \sum_{j=1}^n m_{ij} \le 1\)</span> while <span class="math">\(m_{i,j} \ge 0\)</span>, then <span class="math">\[
\vec{a} M \vec{b}^{\rm T} \le \vec{a}.\vec{b}^{\rm T}.
\]</span></p>
</blockquote>
<p>想到一个递归证明的方法。主要步骤是</p>
<p><span class="math">\[
\vec{a} (M - {\rm I}_n) \vec{b}^{\rm T}=a_1\left[\sum_{i,j=1}^n m_{ij}- n\right]b_1 + \left[ \sum_{i=2}^n (a_i - a_1) \left( \sum_{j=1}^n m_{ij}-1\right)\right]b_1 + a_1 \left[ \sum_{j=2}^n \left( \sum_{i=1}^n m_{ij}-1\right) (b_j - b_1)\right]\\
+ \vec{\alpha} (\mathcal{M}-{\rm I}_{n-1}) \vec{\beta}^T\le \vec{\alpha} (\mathcal{M}-{\rm I}_{n-1}) \vec{\beta}^T
\]</span></p>
<p>其中</p>
<p><span class="math">\[
\vec{\alpha} = 
\begin{pmatrix} 
a_2-a_1 &amp; \ldots &amp; a_n-a_1
\end{pmatrix},~
\mathcal{M} =\begin{pmatrix}
m_{22} &amp; \ldots &amp; m_{2n}\\
\vdots &amp; \ddots &amp; \vdots\\
m_{n2} &amp; \ldots &amp; m_{nn}
\end{pmatrix},~
\vec{\beta} = 
\begin{pmatrix}
b_2-b_1 &amp; \ldots &amp; b_n-b_1
\end{pmatrix}
\]</span></p>
<p><a href="http://www.math.org.cn/forum.php?mod=viewthread&amp;tid=32344">另一个更明晰的方法是：</a> 设<span class="math">\(a_1\geq a_2\geq\cdots\geq a_n\)</span>, <span class="math">\(b_1\geq b_2\geq\cdots\geq b_n\)</span>是两组固定的数. 矩阵<span class="math">\(D=(d_{ij})\)</span>满足: 每个元素非负，并且各行各列元素和为<span class="math">\(1\)</span>, 求以下泛函最大值： <span class="math">\[f(D):=\sum_{i,j=1}^nd_{ij}a_ib_j.\]</span> 用调整法: 如果存在<span class="math">\(i&lt;j,l&lt;k\)</span> 使得<span class="math">\(d_{ik}&gt;0,d_{jl}&gt;0\)</span>，则上述泛函<span class="math">\(f\)</span>一定有其它最大值点，因为可以取<span class="math">\(\varepsilon&gt;0\)</span>充分小，并用 <span class="math">\(d_{ik}-\varepsilon,d_{jl}-\varepsilon\)</span>, <span class="math">\(d_{il}+\varepsilon, d_{jk}+\varepsilon\)</span>代替 <span class="math">\(d_{ik},d_{jl},d_{il},d_{jk}\)</span>后仍满足约束条件，此泛函的增量为： <span class="math">\[\varepsilon(a_j-a_i)(b_k-b_l)\geq0.\]</span> 由此可知，实施上述调整，使得第一行除了第一个元素为<span class="math">\(1\)</span>外其余为<span class="math">\(0\)</span>，泛函的值不减。此时第一列其余元素皆为<span class="math">\(0\)</span>，同理可作类似调整，推出当对角线元素全为<span class="math">\(1\)</span>时，泛函达到最大值： <span class="math">\[\sum_{j=1}^na_jb_j.\]</span></p>
<p>看评论说我们这里的<span class="math">\(M\)</span>竟然是双随机矩阵，而</p>
<blockquote>
<p><a href="http://science.scileaf.com/library/732">双随机矩阵</a>是闭凸集，其上的线性泛函必在顶点处取得极值，而双随机矩阵的顶点就是置换矩阵。因此题目可去掉 ai,bj 的单调性，答案为置换矩阵。</p>
</blockquote>
<p>双随机矩阵的定义正和我们对<span class="math">\(M\)</span>的要求是一致的。</p>
<h2 id="part-2"><a href="#part-2">Part 2</a></h2>
<p><a href="http://en.wikipedia.org/wiki/Doubly_stochastic_matrix">双随机矩阵</a>: In mathematics, especially in probability and combinatorics, a doubly stochastic matrix (also called bistochastic), is a square matrix <span class="math">\(A=(a_{ij})\)</span> of nonnegative real numbers, each of whose rows and columns sums to <span class="math">\(1\)</span>, i.e., <span class="math">\[\sum_i a_{ij}=\sum_j a_{ij}=1.\]</span></p>
<p><a href="http://planetmath.org/proofofbirkhoffvonneumanntheorem">Birkhoff-von Neumann theorem</a>: The set of <span class="math">\(n \times n\)</span> doubly stochastic matrices forms a convex polytope whose vertices are the <span class="math">\(n \times n\)</span> permutation matrices.</p>
<p>主要证明思路是:</p>
<ol style="list-style-type: decimal">
<li>构成<a href="http://en.wikipedia.org/wiki/Birkhoff_polytope">凸多面体</a>;</li>
<li>都能分解为置换矩阵的凸组合.</li>
</ol>
<p>因为双随机矩阵<span class="math">\(M\)</span>中非零元素个数有限, 故可按非零元个数递减归纳证明. 减少非零元素个数的方法是: 从所有非零元素所在位置中挑出一个置换矩阵<span class="math">\(P\)</span>, 用<span class="math">\(M\)</span>减去挑出位置上最小元乘以<span class="math">\(P\)</span>后归一化. 能够挑出<span class="math">\(P\)</span>等价于存在行和列的完美匹配, 需要用到等价的<a href="http://en.wikipedia.org/wiki/Hall&#39;s_marriage_theorem">Hall’s marriage theorem</a>: Let <span class="math">\(G\)</span> be a finite bipartite graph with bipartite sets <span class="math">\(X\)</span> and <span class="math">\(Y\)</span> (<span class="math">\(G:= (X + Y, E)\)</span>). For a set <span class="math">\(W\)</span> of vertices in <span class="math">\(X\)</span>, let <span class="math">\(N_G(W)\)</span> denote the neighborhood of <span class="math">\(W\)</span> in <span class="math">\(G\)</span>, i.e. the set of all vertices in <span class="math">\(Y\)</span> adjacent to some element of <span class="math">\(W\)</span>. The marriage theorem in this formulation states that there is a matching that entirely covers <span class="math">\(X\)</span> if and only if for every subset <span class="math">\(W\)</span> of <span class="math">\(X\)</span>: <span class="math">\[|W| \leq |N_G(W)|.\]</span></p>
<p>关于此定理可以关于<span class="math">\(|X|\)</span>进行递归证明, 详见<a href="https://math.berkeley.edu/~sagrawal/su14_math55/notes_hall.pdf">此简单证明</a>.</p>
<p>利用此定理时, 关键是 <span class="math">\[
|N(A)| = \sum_{v\in N(A), w\in N(N(A))} B_{wv} \ge \sum_{v\in N(A), w\in A} B_{wv} = |A|.
\]</span></p>
<p>如上定理都可以<a href="http://www.theoremoftheday.org/CombinatorialTheory/Birkhoff/TotDBirkhoff.pdf">数独为例</a>:</p>
<table>
<thead>
<tr class="header">
<th align="left">1</th>
<th align="left">2</th>
<th align="left">3</th>
<th align="left">4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">2</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
</tr>
</tbody>
</table>
<p>如上<span class="math">\(4\times 4\)</span>的数独乘以归一化因子<span class="math">\(1/10\)</span>后即是一个双随机矩阵, 可以分解为四个置换矩阵的凸组合: <span class="math">\[
1/10\left[1\times p(2,4)+2\times p(1,2)p(3,4)+3\times p(1,3)+4\times p(1,4)p(2,3)\right].
\]</span></p>
<p>数独也称为<a href="http://en.wikipedia.org/wiki/Latin_square">拉丁方块</a>, 更一般是拉丁长方形. 可以借助Hall’s marriage theorem证明, 拉丁长方形总可以补成拉丁方块. <a href="http://math.ucsb.edu/~padraic/mathcamp_2012/latin_squares/MC2012_LatinSquares_lecture1.pdf">证明思路</a>是:</p>
<ol style="list-style-type: decimal">
<li>将数字<span class="math">\((1, 2, \ldots, n)\)</span>看作<span class="math">\(X\)</span>, 而<span class="math">\(Y=(1,2,\ldots,n)\)</span>是所有列, 若<span class="math">\(x \in X\)</span>未在<span class="math">\(y\in Y\)</span>列出现则称两者相邻.</li>
<li>找到一个完美匹配作为新的一行即可.</li>
</ol>
<div id="footer">
  &copy; 2013-2015 <a href="http://ieden.gitcafe.com">Eden Harder</a>
</div>

